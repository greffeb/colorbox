<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#DC4D01">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>ColorBox - Coloriages Magiques</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #DC4D01;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .display-area {
            flex: 1;
            margin: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible;
            position: relative;
        }

        .polaroid {
            background: #fefefa;
            padding: 14px 14px 72px 14px;
            box-shadow:
                0 3px 6px rgba(0,0,0,0.16),
                0 10px 20px rgba(0,0,0,0.19),
                0 20px 40px rgba(0,0,0,0.12);
            transform: rotate(-1.5deg);
            position: relative;
            max-width: 380px;
            width: 92%;
        }

        /* Subtle tape effect at top */
        .polaroid::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%) rotate(2deg);
            width: 60px;
            height: 24px;
            background: rgba(255, 255, 220, 0.7);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .polaroid-frame {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: #e8e8e8;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        /* Inner shadow overlay on top of content */
        .polaroid-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.15);
            pointer-events: none;
            z-index: 1;
        }

        .polaroid-caption {
            font-family: 'Caveat', cursive;
            font-weight: 500;
            color: #2d2d2d;
            text-align: center;
            padding: 4px 10px;
            height: 58px;
            line-height: 1.25;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            transition: font-size 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .state {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 24px;
            text-align: center;
        }

        .state.active {
            display: flex;
        }

        .state-idle .hint {
            color: #666;
            font-size: 16px;
            max-width: 240px;
            line-height: 1.4;
        }

        .state-idle .hint-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.9;
        }

        .state-recording .mic-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #DC4D01 0%, #c44401 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            animation: pulse 1s infinite;
            margin-bottom: 20px;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(220, 77, 1, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 15px rgba(220, 77, 1, 0); }
        }

        .state-recording .recording-text {
            color: #555;
            font-size: 16px;
        }

        .state-generating .transcribed-text {
            font-family: 'Caveat', cursive;
            font-size: 28px;
            font-weight: 600;
            color: #333;
            margin-bottom: 24px;
            max-width: 100%;
            word-wrap: break-word;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 4px solid #eee;
            border-top: 4px solid #DC4D01;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .state-generating .loading-text {
            margin-top: 16px;
            color: #666;
            font-size: 14px;
        }

        .state-result {
            padding: 0;
        }

        .state-result .result-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Hidden - caption now in polaroid bottom */
        .state-result .result-prompt {
            display: none;
        }

        .state-error .error-icon {
            font-size: 56px;
            margin-bottom: 14px;
        }

        .state-error .error-text {
            color: #555;
            font-size: 16px;
            margin-bottom: 18px;
            white-space: pre-line;
            max-width: 90%;
            line-height: 1.4;
        }

        .retry-btn {
            padding: 12px 28px;
            background: #DC4D01;
            color: white;
            border: none;
            border-radius: 24px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .retry-btn:hover {
            background: #c44401;
        }

        .push-button-container {
            padding: 16px 24px 32px 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            position: relative;
            z-index: 100;
        }

        .push-button {
            width: 130px;
            height: 130px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow:
                0 8px 24px rgba(0, 0, 0, 0.25),
                0 4px 8px rgba(0, 0, 0, 0.15),
                inset 0 2px 4px rgba(255, 255, 255, 0.9);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 44px;
            transition: all 0.15s ease;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            z-index: 10;
        }

        .push-button:active,
        .push-button.recording {
            transform: scale(0.95);
            box-shadow:
                0 4px 12px rgba(0, 0, 0, 0.2),
                inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .push-button.recording {
            background: linear-gradient(145deg, #DC4D01, #c44401);
        }

        .push-button.recording::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid #DC4D01;
            animation: recording-ring 1.5s infinite;
        }

        @keyframes recording-ring {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .toast {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
            z-index: 200;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* ============ Secondary Buttons (Share & History) ============ */
        .secondary-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow:
                0 4px 12px rgba(0, 0, 0, 0.2),
                0 2px 4px rgba(0, 0, 0, 0.12),
                inset 0 1px 3px rgba(255, 255, 255, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.15s ease;
            user-select: none;
            -webkit-user-select: none;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
        }

        .secondary-button:active {
            transform: scale(0.92);
            box-shadow:
                0 2px 6px rgba(0, 0, 0, 0.15),
                inset 0 1px 4px rgba(0, 0, 0, 0.08);
        }
        /* Export Button (was Share) - Renamed to avoid AdBlock */
        .export-btn {
            /* Inherits all secondary-button styles */
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }

        /* ============ History Modal Overlay ============ */
        .history-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 300;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .history-overlay.active {
            display: flex;
            opacity: 1;
        }

        .history-modal {
            background: #fefefa;
            border-radius: 16px;
            width: 100%;
            max-width: 440px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.3),
                0 4px 16px rgba(0, 0, 0, 0.2);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .history-overlay.active .history-modal {
            transform: scale(1);
        }

        .history-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 20px 12px 20px;
            border-bottom: 2px solid #e8e8e8;
        }

        .history-title {
            font-family: 'Caveat', cursive;
            font-size: 32px;
            font-weight: 600;
            color: #DC4D01;
            margin: 0;
        }

        .history-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: #f0f0f0;
            color: #555;
            font-size: 24px;
            font-weight: 300;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            line-height: 1;
        }

        .history-close:hover {
            background: #e0e0e0;
        }

        .history-close:active {
            transform: scale(0.9);
        }

        .history-grid {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .history-item {
            aspect-ratio: 1 / 1;
            background: #e8e8e8;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .history-item:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .history-item:active {
            transform: scale(0.98);
        }

        .history-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .history-empty {
            grid-column: 1 / -1;
            padding: 40px 20px;
            text-align: center;
            color: #999;
        }

        .history-empty-icon {
            font-size: 56px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .history-empty-text {
            font-size: 16px;
            line-height: 1.4;
        }

        /* ============ Responsive: Small screens ============ */
        @media (max-width: 380px) {
            .secondary-button {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }

            .push-button {
                width: 110px;
                height: 110px;
                font-size: 38px;
            }

            .push-button-container {
                gap: 12px;
            }
        }

        .version-indicator {
            position: fixed;
            top: 8px;
            left: 10px;
            font-size: 11px;
            font-weight: 500;
            color: rgba(180, 60, 0, 0.6);
            z-index: 1000;
            pointer-events: none;
            user-select: none;
        }

        </style>
</head>
<body>
    <div class="version-indicator">v8</div>
    <main class="display-area">
        <div class="polaroid">
            <div class="polaroid-frame">
                <div class="state state-idle active" id="stateIdle">
                    <div class="hint-icon">ðŸŽ¨</div>
                    <p class="hint">Maintiens le bouton et dÃ©cris ton dessin !</p>
                </div>

                <div class="state state-recording" id="stateRecording">
                    <div class="mic-icon">ðŸŽ¤</div>
                    <p class="recording-text">Je t'Ã©coute...</p>
                </div>

                <div class="state state-generating" id="stateGenerating">
                    <p class="transcribed-text" id="transcribedText"></p>
                    <div class="loader"></div>
                    <p class="loading-text">Je dessine...</p>
                </div>

                <div class="state state-result" id="stateResult">
                    <img class="result-image" id="resultImage" alt="Coloriage gÃ©nÃ©rÃ©">
                    <div class="result-prompt" id="resultPrompt"></div>
                </div>

                <div class="state state-error" id="stateError">
                    <div class="error-icon">ðŸ˜•</div>
                    <p class="error-text" id="errorText">Oups, quelque chose n'a pas marchÃ©</p>
                    <button class="retry-btn" id="retryBtn">RÃ©essayer</button>
                </div>
            </div>
            <div class="polaroid-caption" id="polaroidCaption"></div>
        </div>
    </main>

    <div class="push-button-container">
        <!-- History Button (Left) -->
        <button class="secondary-button history-button" id="historyButton" aria-label="Voir l'historique">
            ðŸ“š
        </button>

        <!-- Main Push Button (Center) -->
        <button class="push-button" id="pushButton" aria-label="Appuyer pour parler">
            ðŸŽ¤
        </button>

        <!-- Export Button (Right) - Renamed to avoid AdBlock -->
        <button class="secondary-button export-btn" id="exportButton" aria-label="Partager le dessin">
            ðŸ“¤
        </button>
    </div>

    <div class="toast" id="toast"></div>

    <!-- History Modal Overlay -->
    <div class="history-overlay" id="historyOverlay">
        <div class="history-modal">
            <div class="history-header">
                <h2 class="history-title">Mes dessins</h2>
                <button class="history-close" id="historyClose" aria-label="Fermer">âœ•</button>
            </div>
            <div class="history-grid" id="historyGrid">
                <!-- Populated dynamically -->
            </div>
        </div>
    </div>

    <script>
        // ============ App State ============
        const state = {
            currentImage: null,
            currentPrompt: null,
            history: JSON.parse(localStorage.getItem('colorbox_history') || '[]'),
            isRecording: false
        };

        // ============ DOM Elements ============
        const elements = {
            pushButton: document.getElementById('pushButton'),
            retryBtn: document.getElementById('retryBtn'),
            toast: document.getElementById('toast'),
            polaroidCaption: document.getElementById('polaroidCaption'),
            exportButton: document.getElementById('exportButton'),
            historyButton: document.getElementById('historyButton'),
            historyOverlay: document.getElementById('historyOverlay'),
            historyGrid: document.getElementById('historyGrid'),
            historyClose: document.getElementById('historyClose'),
            states: {
                idle: document.getElementById('stateIdle'),
                recording: document.getElementById('stateRecording'),
                generating: document.getElementById('stateGenerating'),
                result: document.getElementById('stateResult'),
                error: document.getElementById('stateError')
            },
            transcribedText: document.getElementById('transcribedText'),
            resultImage: document.getElementById('resultImage'),
            resultPrompt: document.getElementById('resultPrompt'),
            errorText: document.getElementById('errorText')
        };

        // ============ Speech Recognition ============
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;

        // Push-to-talk transcript management (fixes Android stutter bug)
        // - finalTranscript: confirmed words that won't change (isFinal=true)
        // - interimTranscript: current hypothesis, rebuilt each event
        // - accumulatedBeforeRestart: saves finalTranscript when recognition restarts on silence
        let finalTranscript = '';
        let interimTranscript = '';
        let accumulatedBeforeRestart = '';

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.lang = 'fr-FR';
            recognition.continuous = true;  // Keep listening until button released
            recognition.interimResults = true;

            recognition.onresult = (event) => {
                // CRITICAL FIX for Android Chrome:
                // Use event.resultIndex to only process NEW results
                // Final results (isFinal=true) are appended ONCE to finalTranscript
                // Interim results are rebuilt from scratch each time (they can change)

                interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const transcript = result[0].transcript;

                    if (result.isFinal) {
                        // Final result: append to persistent transcript (only counted once)
                        finalTranscript += transcript;
                    } else {
                        // Interim result: just for display, may change
                        interimTranscript += transcript;
                    }
                }

                // Update live display (show what user is saying)
                const displayText = (accumulatedBeforeRestart + finalTranscript + interimTranscript).trim();
                const recordingText = document.querySelector('.recording-text');
                if (recordingText && displayText) {
                    // Show preview of what's being transcribed
                    const previewText = displayText.length > 50
                        ? '...' + displayText.slice(-47)
                        : displayText;
                    recordingText.textContent = previewText;
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error === 'no-speech') {
                    // Ignore no-speech errors while holding button (just silence)
                    if (!state.isRecording) {
                        showToast("Je n'ai rien entendu, rÃ©essaie !");
                        setState('idle');
                    }
                } else if (event.error === 'not-allowed') {
                    showError("ðŸŽ¤ Autorise l'accÃ¨s au micro dans les paramÃ¨tres de Chrome !\n\nMenu â‹® â†’ ParamÃ¨tres â†’ ParamÃ¨tres du site â†’ Microphone");
                    stopRecording();
                } else if (event.error !== 'aborted') {
                    // unexpected error
                    console.warn('Mic error:', event.error);
                    stopRecording();
                    showError("ProblÃ¨me avec le micro. (" + event.error + ")");
                }
            };

            recognition.onend = () => {
                // If button still held, restart recognition (handles browser timeout/silence)
                if (state.isRecording) {
                    // Save what we have before restart (recognition resets results array)
                    accumulatedBeforeRestart += finalTranscript + interimTranscript;
                    finalTranscript = '';
                    interimTranscript = '';

                    try {
                        recognition.start();
                    } catch (e) {
                        console.log('Restart ignored', e);
                    }
                }
            };
        }

        // ============ Kid-Friendly Filter ============
        const blockedWords = [
            'nu', 'nue', 'nus', 'nues', 'sexy', 'sex', 'sexe', 'porn', 'porno',
            'bite', 'queue', 'nichon', 'cul', 'fesse', 'sein', 'poitrine',
            'violence', 'violent', 'sang', 'mort', 'tuer', 'meurtre', 'cadavre',
            'drogue', 'alcool', 'cigarette', 'fumer',
            'arme', 'fusil', 'pistolet', 'couteau', 'guerre',
            'horreur', 'terrifiant', 'cauchemar'
        ];

        function isKidFriendly(text) {
            const lowerText = text.toLowerCase();
            for (const word of blockedWords) {
                if (lowerText.includes(word)) {
                    return false;
                }
            }
            return true;
        }

        // ============ Image Generation ============
        const WORKER_URL = 'https://colorbox-image-api.greffe-b.workers.dev/';

        // Translate French to English to avoid NSFW false positives
        async function translateToEnglish(frenchText) {
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(frenchText)}&langpair=fr|en`);
                const data = await response.json();

                if (data.responseStatus === 200 && data.responseData.translatedText) {
                    const translated = data.responseData.translatedText;
                    console.log(`Translated: "${frenchText}" â†’ "${translated}"`);
                    return translated;
                }

                // Fallback: return original if translation fails
                console.warn('Translation failed, using original text');
                return frenchText;
            } catch (error) {
                console.warn('Translation error:', error);
                return frenchText; // Fallback to original
            }
        }

        // Enrich prompt using LLM (translates + adds kid-friendly context)
        async function enrichPrompt(userPrompt) {
            try {
                const response = await fetch(WORKER_URL.replace(/\/$/, '') + '/enrich', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: userPrompt })
                });

                if (!response.ok) {
                    throw new Error(`Enrichment failed: ${response.status}`);
                }

                const data = await response.json();
                const enriched = data.enriched?.trim();

                if (enriched) {
                    console.log(`Enriched: "${userPrompt}" â†’ "${enriched}"`);
                    return enriched;
                }

                // Fallback to translation only
                return await translateToEnglish(userPrompt);
            } catch (error) {
                console.warn('Enrichment failed, falling back to translation:', error);
                return await translateToEnglish(userPrompt);
            }
        }

        async function generateImage(prompt) {
            // Enrich prompt using LLM (translates French + adds kid-friendly context)
            const enrichedPrompt = await enrichPrompt(prompt);

            // Enhanced FLUX-1 coloring book prompt
            const coloringPrompt = `
        A high-quality children's coloring book illustration:
        ${enrichedPrompt}

        Clean, bold black outlines only.
        Solid white background behind all elements.
        No color, no grayscale, no gradients, no shading, no textures, no shadows.

        Clear, readable composition suitable for children.
        Thick outer contour lines, thinner inner detail lines.
        Smooth vector-style line art.
        Professional kids coloring book aesthetic.
        Crisp edges, high clarity, printable quality.
        `.trim();

            const negativePrompt = `
        color, grayscale, gray, gradient, shading, shadow, texture,
        photorealistic, realistic, dark, horror, scary, abstract,
        messy lines, sketchy lines, thin outlines,
        cluttered background, noisy background,
        watermark, text, logo
        `.trim();

            console.log('Generating image via Cloudflare Worker:', coloringPrompt);

            try {
                const response = await fetch(WORKER_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        prompt: coloringPrompt,
                        negative_prompt: negativePrompt,
                        steps: 6
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    console.error('Worker API error:', errorData);
                    throw new Error(`API request failed: ${response.status}`);
                }

                const blob = await response.blob();
                console.log('Image blob received, size:', blob.size);

                const dataUrl = await blobToDataUrl(blob);
                console.log('Image generation complete! Data URL length:', dataUrl.length);

                return dataUrl;

            } catch (error) {
                console.error('Image generation failed:', error);
                throw error;
            }
        }

        function urlToDataUrl(imageUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    try {
                        const dataUrl = canvas.toDataURL('image/png');
                        resolve(dataUrl);
                    } catch(e) {
                        console.warn('Could not convert to data URL (CORS), using original URL:', e);
                        resolve(imageUrl);
                    }
                };
                img.onerror = reject;
                img.src = imageUrl;
            });
        }

        function blobToDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // ============ State Management ============
        function setState(stateName) {
            Object.values(elements.states).forEach(el => el.classList.remove('active'));
            elements.states[stateName]?.classList.add('active');

            // Clear caption on idle/recording states
            if (stateName === 'idle' || stateName === 'recording') {
                elements.polaroidCaption.textContent = '';
            }
        }

        // ============ Caption Sizing ============
        function updateCaption(text) {
            // Max character limit for safety
            const MAX_LENGTH = 120;
            const displayText = text.length > MAX_LENGTH ? text.substring(0, MAX_LENGTH) + '...' : text;

            elements.polaroidCaption.textContent = displayText;

            // Dynamic font sizing based on text length
            const length = displayText.length;
            let fontSize;

            if (length < 15) {
                fontSize = '36px';  // Massive for very short text
            } else if (length < 35) {
                fontSize = '28px';  // Large for short text
            } else if (length < 60) {
                fontSize = '22px';  // Medium for medium text
            } else if (length < 90) {
                fontSize = '18px';  // Small for long text
            } else {
                fontSize = '15px';  // Very small for very long text
            }

            elements.polaroidCaption.style.fontSize = fontSize;
        }

        // ============ Recording Functions ============
        function startRecording() {
            if (!recognition) {
                showError("La reconnaissance vocale n'est pas supportÃ©e sur ce navigateur.");
                return;
            }

            // Check if site is served over HTTPS or localhost (required for microphone)
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                showError("âš ï¸ Le micro nÃ©cessite HTTPS !\n\nUtilise https:// ou localhost pour accÃ©der au site.");
                return;
            }

            state.isRecording = true;

            // Reset all transcript buffers for new recording session
            finalTranscript = '';
            interimTranscript = '';
            accumulatedBeforeRestart = '';

            elements.pushButton.classList.add('recording');
            setState('recording');

            try {
                recognition.start();
            } catch (e) {
                console.error('Recognition start error:', e);
                showError("Erreur au dÃ©marrage du micro. VÃ©rifie les permissions dans Chrome.");
            }
        }

        function stopRecording() {
            state.isRecording = false;
            elements.pushButton.classList.remove('recording');

            // Reset recording text for next time
            const recordingText = document.querySelector('.recording-text');
            if (recordingText) {
                recordingText.textContent = "Je t'Ã©coute...";
            }

            try {
                recognition?.stop();
            } catch (e) {
                // Ignore errors when stopping
            }

            // Combine all transcript parts for final submission
            // accumulatedBeforeRestart: text from before any recognition restart
            // finalTranscript: confirmed text from current recognition session
            // interimTranscript: unconfirmed hypothesis (include it since user released button)
            const fullTranscript = (accumulatedBeforeRestart + finalTranscript + interimTranscript).trim();

            // Clear for next recording
            finalTranscript = '';
            interimTranscript = '';
            accumulatedBeforeRestart = '';

            if (fullTranscript) {
                handleVoiceInput(fullTranscript);
            } else {
                // Button released with no speech detected
                showToast("Je n'ai rien compris, rÃ©essaie !");
                setState('idle');
            }
        }

        // ============ Voice Input Handler ============
        async function handleVoiceInput(transcript) {
            if (!transcript.trim()) {
                showToast("Je n'ai rien compris, rÃ©essaie !");
                setState('idle');
                return;
            }

            if (!isKidFriendly(transcript)) {
                showToast("Hmm, essaie un autre dessin ! ðŸ™ˆ");
                setState('idle');
                return;
            }

            const userPrompt = transcript.trim();
            state.currentPrompt = userPrompt;
            elements.transcribedText.textContent = userPrompt;
            updateCaption(userPrompt);
            setState('generating');

            try {
                const imageUrl = await generateImage(userPrompt);

                // Set up image load handlers
                elements.resultImage.onload = async function() {
                    console.log('Image loaded successfully');
                    state.currentImage = imageUrl;
                    setState('result');

                    // Try to convert to data URL for history storage (may fail if CORS restricted)
                    try {
                        const dataUrl = await urlToDataUrl(imageUrl);
                        saveToHistory(dataUrl, userPrompt);
                    } catch (e) {
                        console.warn('Could not save to history:', e);
                        saveToHistory(imageUrl, userPrompt);
                    }
                };

                elements.resultImage.onerror = function() {
                    console.error('Image failed to load');
                    showError("Oups, le dessin n'a pas marchÃ©. RÃ©essaie !");
                };

                // Start loading the image
                elements.resultImage.src = imageUrl;
                elements.resultPrompt.textContent = userPrompt;

            } catch (error) {
                console.error('Generation error:', error);
                showError("Oups, le dessin n'a pas marchÃ©. RÃ©essaie !");
            }
        }

        // ============ History Management ============
        function saveToHistory(imageUrl, prompt) {
            const item = {
                id: Date.now(),
                image: imageUrl,
                prompt: prompt,
                date: new Date().toISOString()
            };

            state.history.unshift(item);

            if (state.history.length > 20) {
                state.history = state.history.slice(0, 20);
            }

            // Try to save to localStorage, handle quota errors
            try {
                localStorage.setItem('colorbox_history', JSON.stringify(state.history));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn('Storage quota exceeded, reducing history...');
                    // Remove oldest items until we can save
                    state.history = state.history.slice(0, 10);
                    try {
                        localStorage.setItem('colorbox_history', JSON.stringify(state.history));
                    } catch (e2) {
                        console.error('Could not save even reduced history:', e2);
                        // Clear all history as last resort
                        state.history = [item];
                        localStorage.setItem('colorbox_history', JSON.stringify(state.history));
                    }
                } else {
                    console.error('Could not save to history:', e);
                }
            }

        }

        // ============ Share/Print Functions ============
        async function shareImage() {
            if (!state.currentImage || !state.currentPrompt) {
                showToast("Aucun dessin Ã  partager");
                return;
            }

            try {
                // Convert data URL to blob for sharing
                const response = await fetch(state.currentImage);
                const blob = await response.blob();
                const file = new File([blob], 'coloriage.png', { type: 'image/png' });

                // Check if Web Share API is available
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        files: [file],
                        title: 'Mon coloriage ColorBox',
                        text: state.currentPrompt
                    });
                    console.log('Image shared successfully');
                } else {
                    // Fallback to print if share not available
                    printImage();
                }
            } catch (error) {
                console.error('Share error:', error);
                // If share was cancelled or failed, try print
                if (error.name !== 'AbortError') {
                    printImage();
                }
            }
        }

        function printImage() {
            if (!state.currentImage) {
                showToast("Aucun dessin Ã  imprimer");
                return;
            }

            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                showToast("Autorise les pop-ups pour imprimer");
                return;
            }

            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${state.currentPrompt || 'Coloriage'}</title>
                    <style>
                        body { margin: 0; display: flex; align-items: center; justify-content: center; min-height: 100vh; }
                        img { max-width: 100%; max-height: 100vh; display: block; }
                        @media print { body { margin: 0; } img { width: 100%; height: auto; } }
                    </style>
                </head>
                <body>
                    <img src="${state.currentImage}" alt="Coloriage">
                    <scr` + `ipt>
                        window.onload = function() {
                            window.print();
                            setTimeout(function() { window.close(); }, 500);
                        };
                    </scr` + `ipt>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        // ============ History Modal Functions ============
        function openHistoryModal() {
            renderHistoryGrid();
            elements.historyOverlay.classList.add('active');
        }

        function closeHistoryModal() {
            elements.historyOverlay.classList.remove('active');
        }

        function renderHistoryGrid() {
            // Get last 6 items from history
            const recentHistory = state.history.slice(0, 6);

            if (recentHistory.length === 0) {
                elements.historyGrid.innerHTML = `
                    <div class="history-empty">
                        <div class="history-empty-icon">ðŸŽ¨</div>
                        <p class="history-empty-text">Aucun dessin pour le moment.<br>CrÃ©e ton premier coloriage !</p>
                    </div>
                `;
                return;
            }

            elements.historyGrid.innerHTML = recentHistory.map(item => `
                <div class="history-item" data-id="${item.id}">
                    <img src="${item.image}" alt="${item.prompt}" loading="lazy">
                </div>
            `).join('');

            // Add click handlers
            elements.historyGrid.querySelectorAll('.history-item').forEach(itemEl => {
                itemEl.addEventListener('click', function() {
                    const itemId = parseInt(this.dataset.id);
                    selectHistoryItem(itemId);
                });
            });
        }

        function selectHistoryItem(itemId) {
            const item = state.history.find(h => h.id === itemId);
            if (!item) return;

            // Restore to result view
            state.currentImage = item.image;
            state.currentPrompt = item.prompt;

            elements.resultImage.src = item.image;
            updateCaption(item.prompt);
            setState('result');

            closeHistoryModal();
        }

        // ============ Utility Functions ============
        function showError(message) {
            elements.errorText.textContent = message;
            setState('error');
        }

        function showToast(message) {
            elements.toast.textContent = message;
            elements.toast.classList.add('show');
            setTimeout(() => {
                elements.toast.classList.remove('show');
            }, 3000);
        }

        // ============ Event Listeners ============
        elements.pushButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startRecording();
        });

        elements.pushButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopRecording();
        });

        elements.pushButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startRecording();
        });

        elements.pushButton.addEventListener('mouseup', (e) => {
            e.preventDefault();
            stopRecording();
        });

        elements.pushButton.addEventListener('mouseleave', () => {
            if (state.isRecording) {
                stopRecording();
            }
        });

        elements.retryBtn.addEventListener('click', () => {
            setState('idle');
        });

        // Export/Share button
        elements.exportButton.addEventListener('click', () => {
            shareImage();
        });

        elements.exportButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            shareImage();
        });

        // History button
        elements.historyButton.addEventListener('click', () => {
            openHistoryModal();
        });

        elements.historyButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openHistoryModal();
        });

        // History close button
        elements.historyClose.addEventListener('click', () => {
            closeHistoryModal();
        });

        // Close modal on backdrop click
        elements.historyOverlay.addEventListener('click', (e) => {
            if (e.target === elements.historyOverlay) {
                closeHistoryModal();
            }
        });

        // ============ PWA Service Worker ============
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('SW registered'))
                .catch(err => console.log('SW registration failed:', err));
        }
    </script>
</body>
</html>
